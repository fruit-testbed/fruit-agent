#!/usr/bin/env python
# -*- coding: utf-8 -*-


from __future__ import print_function
import subprocess as sp
import json
import sys
from os import path
import os
import logging
import logging.handlers
import hashlib
import errno


__DOCKER_SOCK__ = '/var/run/docker.sock'
__DOCKER_API_VERSION__ = 'v1.35'
__FRUIT_VALUE__ = '/usr/sbin/fruit-value'
__FRUIT_CONTAINER_DATA_VOLUME__ = '/data/.container-data'

# Any file of '/dev/{__PUBLIC_DEVICES__}*' can be bound to the container
__PUBLIC_DEVICES__ = ['i2c', 'spi', 'ttyUSB']


log = logging.getLogger('fruit-container')
log.setLevel(logging.DEBUG)
handler = logging.handlers.SysLogHandler(address = '/dev/log')
log.addHandler(handler)


def get_device_file(device):
    device = device.lstrip(path.sep)
    for dev in __PUBLIC_DEVICES__:
        if device[:len(dev)] == dev:
            return path.join(path.sep, 'dev', device)


'''
Return a list of Docker containers.
'''
def list_containers():
    if not path.exists(__DOCKER_SOCK__):
        raise RuntimeError, 'Docker daemon is not running.'
    cmd = ['curl', '-fs', '--unix-socket', __DOCKER_SOCK__,
        'http:/%s/containers/json?all=true' % __DOCKER_API_VERSION__]
    return json.loads(sp.check_output(cmd))


'''
Clean-up Docker by removing deleted/exited containers and removing dangling
images. A dangling image is an image whose repository and tag are '<none>'
and it is not being used by any container.
'''
def cleanup(not_removed):
    __remove_fruit_containers(not_removed)
    __remove_non_fruit_exited_containers()
    __remove_dangling_images()


'''
Remove fruit containers unless its name is in 'not_removed' list.
'''
def __remove_fruit_containers(not_removed):
    def __filter(c):
        for (name, ext) in map(lambda n: path.splitext(n), c['Names']):
            if ext == '.fruit' and name[1:] in not_removed:
                return False
        return True

    for container in filter(__filter, list_containers()):
        try:
            if __stop_container(container['Id']) == 0:
                log.info("Stopped container '%s'" % container['Names'])
                __delete_container(container['Id'])
            else:
                log.error("Failed stopping container '%s'" % container['Names'])
        except sp.CalledProcessError as cpe:
            log.error('Failed deleting fruit containers, \
error-code: %d, command: %s' % (cpe.returncode, cpe.cmd))


def __delete_container(cid):
    if not path.exists(__DOCKER_SOCK__):
        raise RuntimeError, 'Docker daemon is not running.'
    return sp.call(['curl', '-fs', '--unix-socket', __DOCKER_SOCK__, '-X',
        'DELETE', 'http:/%s/containers/%s' % (__DOCKER_API_VERSION__, cid)])


def __stop_container(cid):
    if not path.exists(__DOCKER_SOCK__):
        raise RuntimeError, 'Docker daemon is not running.'
    return sp.call(['curl', '-fs', '--unix-socket', __DOCKER_SOCK__, '-X',
        'POST', 'http:/%s/containers/%s/stop' % (__DOCKER_API_VERSION__, cid)])


'''
Remove non-fruit containers, that are containers whose names without extension
'.fruit'.
'''
def __remove_non_fruit_exited_containers():
    def __filter(c):
        return '.fruit' not in map(lambda n: path.splitext(n)[1], c['Names']) \
                and c['State'] == 'exited'

    for container in filter(__filter, list_containers()):
        try:
            __delete_container(container['Id'])
        except sp.CalledProcessError as cpe:
            log.error('Failed deleting (non-fruit) exited-containers, \
error-code: %d, command: %s' % (cpe.returncode, cpe.cmd))


def __remove_dangling_images():
    # remove dangling images ('<none>' in both REPOSITORY and TAG fields)
    try:
        with open(os.devnull, 'w') as FNULL:
            docker = sp.Popen(['docker', 'images'], stdout=sp.PIPE)
            grep = sp.Popen(['grep', '<none> '], stdin=docker.stdout,
                            stdout=sp.PIPE)
            awk = sp.Popen(['awk', '{print $3}'], stdin=grep.stdout,
                           stdout=sp.PIPE)
            sp.call(['xargs', 'docker', 'rmi'], stdin=awk.stdout, stderr=FNULL,
                    stdout=FNULL)
            docker.wait()
            grep.wait()
            awk.wait()
    except sp.CalledProcessError as cpe:
        log.error('Failed deleting dangling container-images, error-code: %d, \
command: %s' % (cpe.returncode, cpe.cmd))


def get_specs_signature(specs):
    return hashlib.sha256(
            json.dumps(specs, sort_keys=True,separators=(',', ':'))
        ).hexdigest()


'''
Convert a relative container volume path to an absolute one.
'''
def __absolute_volume_path(p):
    if not path.exists(__FRUIT_CONTAINER_DATA_VOLUME__):
        try:
            os.makedirs(__FRUIT_CONTAINER_DATA_VOLUME__)
        except OSError as exc:
            if exc.errno == errno.EEXIST and \
                    path.isdir(__FRUIT_CONTAINER_DATA_VOLUME__):
                pass
            else:
                raise exc
    p = path.join(__FRUIT_CONTAINER_DATA_VOLUME__, p.lstrip(path.sep))
    if not path.exists(p):
        try:
            os.makedirs(p)
        except OSError as exc:
            if exc.errno == errno.EEXIST and path.isdir(p):
                pass
            else:
                raise exc
    return p


'''
Deploy Docker containers as specified in config file.
'''
def deploy(name, specs):
    deployed = list_containers()
    name = name + '.fruit'
    docker_name = '/' + name
    signature = get_specs_signature(specs)
    for container in deployed:
        if docker_name in container['Names']:
            if 'fruit.signature' in container['Labels']:
                if container['Labels']['fruit.signature'] == signature:
                    log.info("Container '%s' has been deployed" % name)
                    return True
            # remove existing container because the specs has changed
            try:
                sp.check_call(['docker', 'stop', name])
                log.info("Deleted container '%s'" % name)
            except sp.CalledProcessError as cpe:
                log.error("Failed re-deploying container '%s' due to unable \
stopping the old one, error-code: %d, command: %s" % \
                        (name, cpe.returncode, cpe.cmd))
                return False

    cmd = ['docker', 'run', '--rm', '-d']
    # labels
    cmd += ['-l', 'fruit.signature=%s' % signature]
    cmd += ['-l', 'fruit.specification=%s' %
            json.dumps(specs, sort_keys=True, separators=(',', ':'))]
    # ports
    if 'port' in specs and isinstance(specs['port'], list):
        cmd = reduce(lambda x, y: x + ['-p', y], [cmd] + specs['port'])
    # volume
    if 'volume' in specs and isinstance(specs['volume'], list):
        cmd = reduce(lambda x, y: x + ['-v', __absolute_volume_path(y)],
                     [cmd] + specs['volume'])
    # device
    if 'device' in specs and isinstance(specs['device'], list):
        for dev in specs['device']:
            dev_file = get_device_file(dev)
            if dev_file is not None:
                cmd += ['--device', dev_file]
    # name
    cmd += ['--name', name]
    # image
    cmd += [specs['image']]
    # commands
    if 'command' in specs and isinstance(specs['command'], list):
        cmd += specs['command']

    try:
        sp.check_call(cmd)
        log.info("Started container '%s', command: %s" % (name, ' '.join(cmd)))
    except sp.CalledProcessError as cpe:
        log.error("Failed starting container '%s', error-code: %d, \
command: %s" % (name, cpe.returncode, cpe.cmd))


def main():
    # check if there's another instance of fruit-container is running
    try:
        with open(os.devnull, 'w') as FNULL:
            sp.check_call(['pidof', 'fruit-container'], stdout=FNULL,
                          stderr=FNULL)
            log.info('Exiting because another fruit-container is running.')
            return
    except:
        pass

    try:
        val = sp.check_output([__FRUIT_VALUE__, '/container']).strip()
        if len(val) < 2:
            # no container defined in fruit.json
            containers = {}
        else:
            containers = json.loads(val)
    except sp.CalledProcessError as cpe:
        if cpe.returncode == 2:
            # no container defined in fruit.json
            containers = {}
        else:
            # there's something wrong with 'fruit-value /container'
            log.error('Failed getting container config, error-code: %d, \
command: %s' % (cpe.returncode, cpe.cmd))
            raise RuntimeError, 'ERROR: Failed to get container configs'

    if isinstance(containers, dict):
        for name in containers:
            deploy(name, containers[name])
        cleanup(containers.keys())


if __name__ == '__main__':
    main()
