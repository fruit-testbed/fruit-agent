#!/usr/bin/env python
# -*- coding: utf-8 -*-


from __future__ import print_function
import subprocess as sp
import json
import sys
from os import path
import os
import logging
import logging.handlers
import hashlib


__DOCKER_SOCK__ = '/var/run/docker.sock'
__DOCKER_API_VERSION__ = 'v1.35'
__FRUIT_VALUE__ = '/usr/sbin/fruit-value'


log = logging.getLogger('fruit-container')
log.setLevel(logging.DEBUG)
handler = logging.handlers.SysLogHandler(address = '/dev/log')
log.addHandler(handler)


def list_containers():
    if not path.exists(__DOCKER_SOCK__):
        raise RuntimeError, 'Docker daemon is not running.'
    cmd = ['curl', '-fs', '--unix-socket', __DOCKER_SOCK__,
        'http:/%s/containers/json?all=true' % __DOCKER_API_VERSION__]
    return json.loads(sp.check_output(cmd))


def cleanup(names):
    deployed = list_containers()
    for container in deployed:
        for docker_name in container['Names']:
            docker_name = docker_name.lstrip('/')
            name, ext = path.splitext(docker_name)
            if ext != '.fruit':
                continue
            if name not in names:
                try:
                    sp.check_call(['docker', 'stop', docker_name])
                    log.info("Deleted container '%s' (docker-name: %s)" % (name, docker_name))
                except sp.CalledProcessError as cpe:
                    log.error("Failed deleting container '%s' (docker-name: %s), error-code: %d, command: %s" % \
                            (name, docker_name, cpe.returncode, cpe.cmd))
            break
    __remove_exited_containers()
    __remove_dangling_images()


def __remove_exited_containers():
    # remove 'Exited' container
    try:
        with open(os.devnull, 'w') as FNULL:
            docker = sp.Popen(['docker', 'ps', '-a'], stdout=sp.PIPE)
            grep = sp.Popen(['grep', ' Exited '], stdin=docker.stdout, stdout=sp.PIPE)
            awk = sp.Popen(['awk', '{print $1}'], stdin=grep.stdout, stdout=sp.PIPE)
            sp.call(['xargs', 'docker', 'rm'], stdin=awk.stdout, stderr=FNULL, stdout=FNULL)
            docker.wait()
            grep.wait()
            awk.wait()
    except sp.CalledProcessError as cpe:
        log.error('Failed deleting exited-containers, error-code: %d, command: %s' % \
                (cpe.returncode, cpe.cmd))


def __remove_dangling_images():
    # remove dangling images ('<none>' in both REPOSITORY and TAG fields)
    try:
        with open(os.devnull, 'w') as FNULL:
            docker = sp.Popen(['docker', 'images'], stdout=sp.PIPE)
            grep = sp.Popen(['grep', '<none> '], stdin=docker.stdout, stdout=sp.PIPE)
            awk = sp.Popen(['awk', '{print $3}'], stdin=grep.stdout, stdout=sp.PIPE)
            sp.call(['xargs', 'docker', 'rmi'], stdin=awk.stdout, stderr=FNULL, stdout=FNULL)
            docker.wait()
            grep.wait()
            awk.wait()
    except sp.CalledProcessError as cpe:
        log.error('Failed deleting dangling container-images, error-code: %d, command: %s' % \
                (cpe.returncode, cpe.cmd))


def get_specs_signature(specs):
    return hashlib.sha256(json.dumps(specs, sort_keys=True, separators=(',', ':'))).hexdigest()


def deploy(name, specs):
    deployed = list_containers()
    name = name + '.fruit'
    docker_name = '/' + name
    signature = get_specs_signature(specs)
    for container in deployed:
        if docker_name in container['Names']:
            log.info("Container '%s' has been deployed" % name)
            return True

    cmd = ['docker', 'run', '--rm', '-d']
    # labels
    cmd += ['-l', 'fruit.signature=%s' % signature]
    cmd += ['-l', 'fruit.specification=%s' % json.dumps(specs, sort_keys=True, separators=(',', ':'))]
    # parameters
    if 'parameters' in specs and isinstance(specs['parameters'], list):
        cmd = cmd + specs['parameters']
    # name
    cmd += ['--name', name]
    # image
    cmd += [specs['image']]
    # commands
    if 'command' in specs and isinstance(specs['command'], list):
        cmd += specs['command']

    try:
        sp.check_call(cmd)
        log.info("Started container '%s' (docker-name: %s) -- %s" % \
                (name, docker_name, ' '.join(cmd)))
    except sp.CalledProcessError as cpe:
        log.error("Failed deleting container '%s' (docker-name: %s), error-code: %d, command: %s" % \
                (name, docker_name, cpe.returncode, cpe.cmd))


def main():
    # check if there's another instance of fruit-container is running
    try:
        with open(os.devnull, 'w') as FNULL:
            sp.check_call(['pidof', 'fruit-container'], stdout=FNULL, stderr=FNULL)
            log.info('Exiting because another fruit-container is running.')
            return
    except:
        pass

    try:
        val = sp.check_output([__FRUIT_VALUE__, '/container']).strip()
        if len(val) < 2:
            # no container defined in fruit.json
            containers = {}
        else:
            containers = json.loads(val)
    except sp.CalledProcessError as cpe:
        if cpe.returncode == 2:
            # no container defined in fruit.json
            containers = {}
        else:
            # there's something wrong with 'fruit-value /container'
            log.error('Failed getting container config, error-code: %d, command: %s' % \
                    (cpe.returncode, cpe.cmd))
            raise RuntimeError, 'ERROR: Failed to get container configs'

    if isinstance(containers, dict):
        for name in containers:
            deploy(name, containers[name])
        cleanup(containers.keys())


if __name__ == '__main__':
    main()
