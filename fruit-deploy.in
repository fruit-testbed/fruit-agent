#!/bin/sh

server_address="fruit-testbed.org"
server_api_prefix="/api"
src_config=/media/mmcblk0p1/fruit.json
config_local=/run/fruit.json@local
config_server=/run/fruit.json@server

copy_config_local_to_run() {
	if [ -e ${src_config} ]; then
		cp -f ${src_config} ${config_local}
		[ $? -ne 0 ] && logger -st fruit "ERROR: cannot copy to /run/fruit.json"
	fi
	[ ! -e ${config_local} ] && echo '{}' > ${config_local}
	chmod 0400 ${config_local}
}

download_resource() {
	# $1: resource name to be download
	# $2: target output file

	local name=$(cat /etc/hostname)
	local url="https://${server_address}${server_api_prefix}/node/${name}/$1"
	local api_key=$(valueof '\["api_key"\]')
	[ "$api_key" = "" ] \
		&& logger -st fruit "ERROR: 'api_key' is not defined in fruit.json" \
		&& return 1
	mkdir -p "$(dirname "$2")" \
		&& curl -sL -o "$2" -H "X-API-Key: ${api_key}" ${url}
	return $?
}

download_config_server_to_run() {
	download_resource "config" ${config_server}
	[ $? -ne 0 ] \
		&& logger -st fruit "WARNING: Failed downloading config from server" \
		&& return 1
	chmod 0400 ${config_server}
	return $?
}

download_ssh_public_key() {
	local target="/root/.ssh/authorized_keys"
	download_resource "ssh_key" ${target}
	[ $? -ne 0 ] \
		&& logger -st fruit "WARNING: Failed to download SSH Public Key from server" \
		&& return 0
	chmod 0700 $(dirname "$target") && chmod 0640 ${target}
	return $?
}

setup_openvpn() {
	local enabled=$(valueof '\["vpn"\]')
	[ "$enabled" != true ] && return 0

	local config="/run/openvpn.tar.gz"
	download_resource "openvpn" ${config}
	[ $? -ne 0 ] \
		&& logger -st fruit "WARNING: Failed to download OpenVPN config from server" \
		&& return 1
	tar -C /etc/openvpn/ -xzf ${config} \
		&& rc-update add openvpn default \
		&& rc-service openvpn start
	local ret=$?
	[ $ret -ne 0 ] && logger -st fruit "ERROR: Failed to setup OpenVPN"
	return $ret
}

valueof() {
	local value=""
	if [ -e ${config_server} ]; then
		value=$(JSON.sh < ${config_server} | grep $1 | cut -f2)
	fi
	if [ "$value" = "" ] || [ "${value}" = '""' ]; then
		value=$(JSON.sh < ${config_local} | grep $1 | cut -f2)
		if [ "$value" = "" ] || [ "${value}" = '""' ]; then
			echo
		else
			echo ${value} | xargs printf
		fi
	else
		echo ${value} | xargs printf
	fi
}

setup_user_root() {
	hash=$(valueof '\["root-password"\]')
	if [ "$hash" != "" ]; then
		sed -i '/^root/ d' /etc/shadow && \
			echo "root:$hash:1:0:99999:7:::" >> /etc/shadow && \
			logger -st fruit "Updated root's password"
	fi
}

serial() {
	cat /proc/cpuinfo | grep Serial | awk '{print $3}' | sed 's/^0*//'
}

setup_hostname() {
	hostname="pi$(serial)"
	echo "$hostname" > /etc/hostname
	echo "127.0.1.1   $hostname" >> /etc/hosts
	hostname $hostname
	logger -st fruit "Set hostname to $hostname"
}

setup_timezone() {
	zone=$(valueof '\["timezone"\]')
	if [ "$zone" = "" ]; then
		zone="GB"
	fi
	zone=$(echo "$zone" | awk '{print toupper($0)}')
	setup-timezone -z $zone && \
		logger -st fruit "Set timezone to $zone"
}

setup_keyboard() {
	local keyboard=$(valueof '\["keyboard"\]')
	if [ "$keyboard" = "" ]; then
		keyboard="gb"
	fi
	local desired_keymap=$(echo "$keyboard" | cut -d' ' -f1)
	local desired_variant=$(echo "$keyboard" | cut -d' ' -f2)

	. /etc/conf.d/keymaps
	local current_variant=$(basename "KEYMAP")
	local current_variant="${current_variant%%.*}"

	if [ "$current_variant" != "$desired_variant" ]; then
		setup-keymap $desired_keymap $desired_variant && \
			logger -st fruit "Set keyboard to keymap=$desired_keymap variant=$desired_variant"
	fi
}

setup_ntpd() {
	local ret=0
	local servers=$(valueof '\["ntp"\]')
	servers="pool.ntp.org time.apple.com $servers"
	for server in ${servers}; do
		echo "server ${server}" >> /etc/ntp.conf
		ret=$((ret + $?))
	done
	[ ${ret} -eq 0 ] \
		&& echo 'NTPD_OPTS="-N"' > /etc/conf.d/ntpd \
		&& rc-service ntpd start
	ret=$((ret + $?))

	[ ${ret} -ne 0 ] && logger -st fruit "ERROR: Setup ntpd failed"
}

setup_wpa_supplicant() {
	ssid=$(valueof '\["wpa","ssid"\]')
	[ "$ssid" = "" ] && return 1

	[ "$wpa" = yes ] && return 0
	wpa=yes

	username=$(valueof '\["wpa","username"\]')
	password=$(valueof '\["wpa","password"\]')

	if [ "$username" != "" ]; then
		cat > /etc/wpa_supplicant/wpa_supplicant.conf <<EOL
network={
	ssid="$ssid"
	scan_ssid=1
	key_mgmt=WPA-EAP
	eap=PEAP
	phase1="peaplabel=0"
	phase2="auth=MSCHAPV2"
	identity="$username"
	password="$password"
}
EOL
	else
		wpa_passphrase $ssid $password > /etc/wpa_supplicant/wpa_supplicant.conf
	fi
	ret=$?
	logger -st fruit "Set up wpa_supplicant SSID=$ssid"
	return $ret
}

# $0: interface to be set up
# $1: interface requires wpa_supplicant
setup_network_interface() {
	iface=$1
	wpa_supp=$2
	addr=$(valueof "\[\"network\",\"$iface\"\]")
	if [ "$addr" = "" ]; then
		addr="dhcp"
	fi

	if [ "$addr" = "dhcp" ]; then
		cat >> /etc/network/interfaces <<-EOL

			auto $iface
			iface $iface inet dhcp
		EOL
		[ "$wpa_supp" = yes ] && cat >> /etc/network/interfaces <<EOL
	pre-up wpa_supplicant -B -c/etc/wpa_supplicant/wpa_supplicant.conf -i${iface}
	post-down killall -q wpa_supplicant
EOL
		logger -st fruit "Set $iface to $addr"
	else
		ipaddr=$(sipcalc "$addr" | grep 'Host address\t' | awk '{print $4}')
		if [ "$ipaddr" = "" ]; then
			logger -st fruit "ERROR: invalid address of $iface: $ipaddr"
			false
		else
			netmask=$(sipcalc "$addr" | grep 'Network mask\t' | awk '{print $4}')
			network=$(sipcalc "$addr" | grep 'Network address\t' | awk '{print $4}')
			broadcast=$(sipcalc "$addr" | grep 'Broadcast address\t' | awk '{print $4}')
			cat >> /etc/network/interfaces <<EOL

auto $iface
iface $iface inet static
	address $ipaddr
	netmask $netmask
	network $network
	broadcast $broadcast
EOL
			[ "$wpa_supp" = yes ] && cat >> /etc/network/interfaces <<EOL
	pre-up wpa_supplicant -B -c/etc/wpa_supplicant/wpa_supplicant.conf -i${iface}
	post-down killall -q wpa_supplicant
EOL
			logger -st fruit "Set $iface to $addr"
		fi
	fi
}

setup_network() {
	local ifaces=$(ip -o link show | cut -d' ' -f2 | sed 's/:$//')
	local wpa=no

	# loopback
	cat > /etc/network/interfaces <<-EOL
		auto lo
		iface lo inet loopback

	EOL

	for iface in ${ifaces}; do
		case "$iface" in
			eth*)
				setup_network_interface "$iface"
				;;
			wlan*)
				setup_wpa_supplicant && \
					setup_network_interface "$iface" "yes"
				;;
		esac
	done
}

setup_monitor() {
	if [ -e /usr/sbin/fruit-monitor ] && [ -e /etc/crontabs/root ] \
		&& [ "$(grep '/usr/sbin/fruit-monitor' /etc/crontabs)" = "" ]
	then
		printf "*/1\t*\t*\t*\t*\t/usr/sbin/fruit-monitor" >> /etc/crontabs/root \
			&& logger -st fruit "Set up fruit-monitor"
	else
		logger -st fruit "ERROR: Failed to set up fruit-monitor"
	fi
}

setup_data_volume() {
	local mmcdev=/dev/mmcblk0
	local newdev=/dev/mmcblk0p4
	# Reference: https://unix.stackexchange.com/questions/136269/corruption-proof-sd-card-filesystem-for-embedded-linux
	local fstype=btrfs
	local mkfs=mkfs.btrfs
	# From https://wiki.debian.org/Btrfs (question: What are the
	# recommended options for installing on a pendrive, a SD card or
	# a slow SSD drive?)
	local fsopts="noatime,compress=lzo,commit=0,ssd_spread,autodefrag"
	local dir=/media/data
	local ret=0

	if [ $(fdisk -lu ${mmcdev} | grep "$newdev" | wc -l) -eq 0 ]; then
		modprobe $fstype 1>/dev/null && \
		{
			freesize=$(parted -ms ${mmcdev} unit MB print free | grep ':free;' | tail -1 | cut -d':' -f4)
			freesize=${freesize%MB}
			if [ "$freesize" != "" ] && [ ${freesize} -gt 100 ]; then
				start=$(parted -ms ${mmcdev} unit MB print free | grep ':free;' | tail -1 | cut -d':' -f2)
				parted -s ${mmcdev} mkpart primary ${fstype} ${start} 100%
				if [ $(blkid ${newdev} | grep "TYPE=\"${fstype}\"" | wc -l) -eq 0 ]; then
					${mkfs} -f ${newdev}
				fi
			else
				false
			fi
		} && \
		logger -st fruit "Created data volume"
		ret=$((ret + $?))
	fi

	if [ $ret -eq 0 ] && [ $(mount | grep ${newdev} | wc -l) -eq 0 ]; then
		mkdir -p ${dir} \
			&& mount -t ${fstype} -o ${fsopts} ${newdev} ${dir} \
			&& chmod 1777 ${dir} \
			&& logger -st fruit "Mounted data volume onto ${dir}"
		ret=$((ret + $?))
	fi

	[ $ret -ne 0 ] && logger -st fruit "ERROR: Setup data volume failed"

	return $ret
}

setup_docker() {
	local enabled=$(valueof '\["docker"\]')
	local datadir=/media/data
	local ret=0

	if [ $(mount | grep " on ${datadir} " | wc -l) -ne 0 ] && \
	   [ $(mount | grep "overlay on /var/lib/docker " | wc -l) -eq 0 ] ; then
		target=/var/lib/docker
		upperdir=${datadir}/.docker/docker
		workdir=${datadir}/.docker/work
		mkdir -p ${target} ${upperdir} ${workdir} \
			&& mount -t overlay -o lowerdir=${target},upperdir=${upperdir},workdir=${workdir} overlay ${target} \
			&& logger -t fruit "Mounted an overlay on top of /var/lib/docker"
		ret=$((ret + $?))
	fi

	if [ "$enabled" = true ]; then
		[ $(rc-update show default | grep docker | wc -l) -eq 0 ] \
			&& rc-update add docker default
		rc-service docker start
	else
		[ $(rc-update show default | grep docker | wc -l) -ne 0 ] \
			&& rc-update del docker default
		rc-service docker stop
	fi
	ret=$((ret + $?))

	[ $ret -ne 0 ] && logger -st fruit "ERROR: Setup Docker failed"

	return $ret
}

setup_sshd() {
	local config=/etc/ssh/sshd_config
	sed -i 's/^#PermitRootLogin prohibit-password/PermitRootLogin prohibit-password/g' ${config} \
		&& sed -i 's/^#PasswordAuthentication yes/PasswordAuthentication no/g' ${config}
	return $?
}

##### main #####

case "$(rc-status -r)" in
	boot)
		copy_config_local_to_run
		setup_hostname
		setup_network
		setup_monitor
		setup_sshd
		;;
	default)
		download_config_server_to_run
		download_ssh_public_key
		setup_ntpd
		setup_user_root
		setup_timezone
		setup_keyboard
		setup_data_volume
		setup_docker
		setup_openvpn
		;;
	*)
		true
		;;
esac

exit 0
