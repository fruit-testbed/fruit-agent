#!/usr/bin/env python
# -*- coding: utf-8 -*-

import json
import subprocess as sp
import re
import os.path as path
import tempfile
import os
import sys
import argparse
import syslog
import traceback


__DOCKER_SOCK__ = "/var/run/docker.sock"
__DOCKER_API_VERSION__ = "v1.35"

__P2P_UPDATE_SOCK__ = "/var/run/p2pupdate.sock"
__P2P_UPDATE_VERSION__ = "v1"


def _cpus():
    data = {}
    with open("/proc/stat") as fin:
        for line in fin:
            if line[:3] != "cpu":
                break
            if line[:4] == "cpu ":
                continue
            parts = re.split("\s+", line.strip())
            label = parts.pop(0)
            user, nice, system, idle, iowait, irq, softirq, steal, guest, \
                    guest_nice = map(lambda s: float(s), parts)
            idle = idle + iowait
            non_idle = user + nice + system + irq + softirq + steal
            total = idle + non_idle
            data[label] = {
                "usage": 100 * non_idle / total,
                "idle": 100 * idle / total,
                "user": 100 * user / total,
                "system": 100 * system / total,
            }
    return data


def _memory():
    lines = sp.check_output(["free", "-b"]).splitlines()
    _, total, used, free, _, buffers, _ = re.split("\s+", lines[1].strip())
    return {
        "total": total,
        "used": used,
        "free": free,
        "buffers": buffers
    }


def _volumes():
    lines = sp.check_output(["df", "-T"]).strip().splitlines()
    lines.pop(0)
    included = ["/", "/media/root-rw", "/media/root-ro", "/media/data"]
    volumes = {}
    for line in lines:
        fs, typ, size, used, free, _, mounted = re.split("\s+", line.strip())
        if mounted in included:
            volumes[mounted] = {
                "filesystem": fs,
                "type": typ,
                "size": size,
                "used": used,
                "free": free,
            }
    return volumes


def _os_service():
    lines = sp.check_output(["rc-status", "-C"]).strip().splitlines()
    lines.pop(0)
    services = {}
    for line in lines:
        name, _, status, _ = re.split("\s+", line.strip())
        services[name] = status
    return services


def _os_mode():
    try:
        mode = sp.check_output(["fruit-value", '\["mode"\]']).strip()
        if mode in ["master", "slave"]:
            return mode
    except sp.CalledProcessError as cpe:
        pass
    return "standalone"


def _os_hostname():
    try:
        return sp.check_output(["hostname"]).strip()
    except:
        return None


def _os_master_address():
    # TODO: implement this when creating OS image for master node
    return None


def _pkg_version(name):
    try:
        lines = sp.check_output(["apk", "version", name]).splitlines()
        return re.split("\s+", lines[1])[0].lstrip("%s-" % name)
    except:
        return None


def _os_uptime():
    try:
        return sp.check_output(["uptime"]).strip()
    except:
        return None


def _os():
    return {
        "version": sp.check_output(["grep", "VERSION", "/etc/os-release"]).split("=")[1].strip(),
        "built_timestamp": sp.check_output(["grep", "BUILT_TIMESTAMP", "/etc/os-release"]).split("=")[1].strip(),
        "uptime": _os_uptime(),
        "fruit-agent": _pkg_version("fruit-agent"),
        "p2p-update": _pkg_version("p2p-update"),
        "mode": _os_mode(),
        "timezone": sp.check_output(["date", "+%Z %z"]).strip(),
        "local_datetime": sp.check_output(["date", "-R"]).strip(),
        "service": _os_service(),
        "master_address": _os_master_address(),
        "hostname": _os_hostname(),
    }


def _docker():
    return {
        "images": _docker_images(),
        "containers": _docker_containers(),
    }


def _docker_images():
    docker_sock = "/var/run/docker.sock"
    if not path.exists(docker_sock):
        return None
    cmd = ["curl", "-fs", "--unix-socket", docker_sock,
           "http:/%s/images/json?all=true" % __DOCKER_API_VERSION__]
    return json.loads(sp.check_output(cmd))


def _docker_containers():
    docker_sock = "/var/run/docker.sock"
    if not path.exists(docker_sock):
        return None
    cmd = ["curl", "-fs", "--unix-socket", docker_sock,
           "http:/%s/containers/json?all=true" % __DOCKER_API_VERSION__]
    return json.loads(sp.check_output(cmd))


def _board():
    serial = sp.check_output(["piserial"]).strip()

    cat = sp.Popen(["cat", "/proc/cpuinfo"], stdout=sp.PIPE)
    line = sp.check_output(["grep", "Revision"], stdin=cat.stdout)
    cat.wait()
    _, _, revision = re.split("\s+", line.strip())

    model = sp.check_output(["cat", "/proc/device-tree/model"]).strip()
    model = model[:-1]

    with open("/sys/class/thermal/thermal_zone0/temp", "r") as fin:
        tempC = float(fin.read()) / 1000.

    return {
        "serial": serial,
        "revision": revision,
        "model": model,
        "temperature": tempC,
    }


def _network():
    nets = {}
    lines = sp.check_output(["ip", "-o", "link", "show"]).strip().splitlines()
    for line in lines:
        _, iface, _, _, _, _, _, _, state, _ = line.split(" ", 9)
        iface = iface.rstrip(":")
        if iface != "lo":
            if state == "DOWN":
                nets[iface] = None
                continue
            ip = sp.Popen(["ip", "addr", "show", "dev", iface, "scope", "global"], stdout=sp.PIPE)
            inets = sp.check_output(["grep", " inet"], stdin=ip.stdout)
            ip.wait()
            nets[iface] = []
            for inet in inets.strip().splitlines():
                _, addr, _ = inet.lstrip().split(" ", 2)
                nets[iface].append(addr)
    return nets


def _api_key():
    try:
        return sp.check_output(["fruit-value", '\["api_key"\]']).strip()
    except:
        return ""


def _fruit_json():
    local_config = "/run/fruit.json@local"
    server_config = "/run/fruit.json@server"
    secrets = ["api_key", "wpa"]
    if not path.exists(local_config):
        local = None
    else:
        with open(local_config, "r") as fin:
            local = json.load(fin)
            for key in secrets:
                local.pop(key, None)

    if not path.exists(server_config):
        server = None
    else:
        with open(server_config, "r") as fin:
            server = json.load(fin)

    return {"local": local, "server": server}


def piid():
    piid = None
    try:
        piid = sp.check_output(["piserial"]).strip()
        if piid != "":
            piid = "pi%s" % piid
    except:
        pass
    return piid


def _p2p_update():
    return {
        "config": _p2p_update_config(),
        "overlay": _p2p_update_overlay(),
        "updates": _p2p_update_updates(),
    }


def _p2p_update_config():
    if not path.exists(__P2P_UPDATE_SOCK__):
        return None
    url = "http://%s/config" % __P2P_UPDATE_VERSION__
    cmd = ["curl", "-fs", "--unix-socket", __P2P_UPDATE_SOCK__, url]
    try:
        return json.loads(sp.check_output(cmd))
    except sp.CalledProcessError:
        return None


def _p2p_update_overlay():
    if not path.exists(__P2P_UPDATE_SOCK__):
        return None
    url = "http://%s/overlay" % __P2P_UPDATE_VERSION__
    cmd = ["curl", "-fs", "--unix-socket", __P2P_UPDATE_SOCK__, url]
    try:
        stat = json.loads(sp.check_output(cmd))
    except sp.CalledProcessError:
        stat = None
    if isinstance(stat, dict):
        url = "http://%s/overlay/peers" % __P2P_UPDATE_VERSION__
        cmd = ["curl", "-fs", "--unix-socket", __P2P_UPDATE_SOCK__, url]
        try:
            stat['peers'] = json.loads(sp.check_output(cmd))
        except sp.CalledProcessError:
            pass
    return stat


def _p2p_update_updates():
    if not path.exists(__P2P_UPDATE_SOCK__):
        return None
    url = "http://%s/update" % __P2P_UPDATE_VERSION__
    cmd = ["curl", "-fs", "--unix-socket", __P2P_UPDATE_SOCK__, url]
    try:
        uuids = json.loads(sp.check_output(cmd))
    except sp.CalledProcessError:
        return None
    if isinstance(uuids, list):
        updates = {}
        for uuid in uuids:
            url2 = "%s/%s" % (url, uuid)
            cmd = ["curl", "-fs", "--unix-socket", __P2P_UPDATE_SOCK__, url2]
            try:
                updates[uuid] = json.loads(sp.check_output(cmd))
            except sp.CalledProcessError:
                pass
        return updates


def generate():
    return {
        "id": piid(),
        "os": _os(),
        "volumes": _volumes(),
        "docker": _docker(),
        "board": _board(),
        "network": _network(),
        "cpus": _cpus(),
        "memory": _memory(),
        "fruit.json": _fruit_json(),
        "p2p-update": _p2p_update(),
    }


def send():
    host = "fruit-testbed.org"
    fd, fname = tempfile.mkstemp(text=True)
    try:
        with os.fdopen(fd, 'w') as fout:
            json.dump(generate(), fout)
        url = "https://%s/api/monitor/%s" % (host, piid())
        header1 = "Content-Type: application/json"
        header2 = "X-API-Key: %s" % _api_key()
        exitcode = sp.check_call(["curl", "-fs", "-X", "POST", "-H", header1,
                                  "-H", header2, "-d", "@%s" % fname, url])
        if exitcode == 0:
            syslog.syslog("Sent monitoring data to %s" % host)
        else:
            syslog.syslog(syslog.LOG_ERR, "Failed to send monitoring data to %s" % host)
        return exitcode
    except:
        e1, e2, e3 = sys.exc_info()
        syslog.syslog(syslog.LOG_ERR, "Failed to send monitoring data to %s -- %s" % (host, traceback.format_exc()))
        raise e1, e2, e3
    finally:
        os.remove(fname)


def print_usage():
    print "--- Usage ---"
    print " Send data to server: %s" % sys.argv[0]
    print "Print data to stdout: %s -" % sys.argv[0]

    
if __name__ == "__main__":
    syslog.openlog(ident="fruit-monitor")
    if len(sys.argv) >= 2:
        if sys.argv[1] == "-":
            json.dump(generate(), sys.stdout)
            sys.stdout.flush()
            print ""
        else:
            print_usage()
    else:
        sys.exit(send())
